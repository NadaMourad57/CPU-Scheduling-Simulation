# CPU Scheduling Policies 
---

## Overview

This program simulates and visualizes CPU scheduling algorithms. The implemented algorithms include:

1. FCFS (First Come First Serve) 
2. RR (Round Robin)
3. SPN (Shortest Process Next)
4. SRT (Shortest Remaining Time)
5. HRRN (Highest Response Ratio Next)
6. FB-1 (Feedback where all queues have q=1)
7. FB-2i (Feedback where all queues have q=2i)
8. Aging




##### 6. FB-1 (Feedback where all queues have q=1)
- create priority queues vector as many as the max service time
- arrange processes by arrival time 
- for process in processes, first check if the arrival time=current time
- add to ready queue 1
- if queue i is not empty pop from ready queue and add to output reduce service time by 1
- if remaining service time of process = 0 remove from processes
- else push in next priority queue i+1




The program supports two modes:
- **Trace**: Visualizes process activity on the CPU timeline.



- **Stats**: Outputs scheduling statistics.
---

## Input Format

1. **Operation Mode**: `trace` or `stats`.
2. **Algorithms**: Comma-separated list with optional parameters (`ID-Quantum`, e.g., `2-4` for RR with `q=4`).
3. **Last Instant**: Integer specifying the simulation end time.
4. **Process Count**: Total number of processes.
5. **Processes**:
   - Format: `Name,Arrival Time,Service Time` (for algorithms 1–7).

### Example Input

```c
trace  //outpute mode trace or stats
1,2-4 //comma separataed list of algo and quantum
20 // last instance
3 //number of process
//process name, start, finish
A,0,5
B,2,3
C,4,6
```
---

## Output Format

- **Trace Mode**: Visualizes process activity using `*` (running) and `.` (waiting).
- **Stats Mode**: Outputs statistics including turnaround and waiting times.

### Example Output

#### Output:
**Trace mode**
```plaintext

FCFS  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 
------------------------------------------------
A     |*|*|*| | | | | | | | | | | | | | | | | | 
B     | | |.|*|*|*|*|*|*| | | | | | | | | | | | 
C     | | | | |.|.|.|.|.|*|*|*|*| | | | | | | | 
D     | | | | | | |.|.|.|.|.|.|.|*|*|*|*|*| | | 
E     | | | | | | | | |.|.|.|.|.|.|.|.|.|.|*|*| 
------------------------------------------------
```
**Stats mode**

### Formulas

#### 1. **Finish Time**
\[
\text{Finish Time} = \text{Last occurance in output string} 
\]

#### 2. **Turnaround Time**
\[
\text{Turnaround Time} = \text{Finish Time} - \text{Arrival Time(given)}
\]

#### 3. **Normalized Turnaround Time (NormTurn)**
\[
\text{NormTurn} = \frac{\text{Turnaround Time}}{\text{Service Time(given)}}
\]

#### 4. **Mean Values**

- **Mean Turnaround Time**:
\[
\text{Mean Turnaround} = \frac{\text{Sum of Turnaround Times}}{\text{Number of Processes}}
\]

- **Mean NormTurn**:
\[
\text{Mean NormTurn} = \frac{\text{Sum of NormTurn Values}}{\text{Number of Processes}}
\]
```plaintext

FCFS
Process    |  A  |  B  |  C  |  D  |  E  |
Arrival    |  0  |  2  |  4  |  6  |  8  |
Service    |  3  |  6  |  4  |  5  |  2  | Mean|
Finish     |  3  |  9  | 13  | 18  | 20  |-----|
Turnaround |  3  |  7  |  9  | 12  | 12  | 8.60|
NormTurn   | 1.00| 1.17| 2.25| 2.40| 6.00| 2.56|
```


---

## Functions

### `parseInput`

Parses the input data from `stdin`.

- **Arguments**:
  - `std::string& operation`: Operation mode (`trace` or `stats`).
  - `std::vector<std::pair<int, int>>& algorithms`: Scheduling algorithms (`{algorithm_id, quantum}`).
  - `int& lastInstant`: Last simulation time.
  - `int& processCount`: Number of processes.
  - `std::vector<std::tuple<std::string, int, int>>& processes`: Process details (`{name, arrival_time, service_time/priority}`).

- **Returns**: `void`.

---

### `fcfs`

Implements the First Come First Serve scheduling algorithm.

- **Arguments**:
  - `const std::vector<std::tuple<std::string, int, int>>& processes`: List of processes (`{name, arrival_time, service_time}`).

- **Returns**: `void`.
- **Output**: Prints process details, average turnaround time, and waiting time.

---
### Compilation

Use the provided `Makefile` to compile the program:

```bash
make
```

This creates an executable named `cpu-scheduling_algo`.

---

### Execution

TODO: add here the execution

---

## Directory Structure

```plaintext
.
├── src/                # Source code files
├── Makefile            # Build instructions
├── test_cases/         # Input/output test files
├── README.md           # Documentation
```







### Directory Structure
```
lab6
├── CPU-Scheduling-Simulation/      # Folder containing the simulation code
│   ├── cpu_scheduling_algo.cpp    # Source code for CPU scheduling algorithms
│   ├── cpu_scheduling_algo.o      # Object file generated by the compiler
│   ├── CPU-Scheduling-Simulation  # Executable program
│   ├── Makefile                   # Makefile to compile the program
│   └── README.md                  # README file for this lab
└── ../testcases/                  # Folder containing input and output test cases
    ├── 01a-input.txt             # Input file for testing
    ├── 01a-output.txt            # Output file for expected results
    ├── 02a-input.txt             # Another test case input
    ├── 02a-output.txt            # Expected output for the second test case
    └── ...                       # Additional input/output test cases
```


**to run:**
```
cd ~/Desktop/Operating_Systems/OS\ Labs/lab6/CPU-Scheduling-Simulation
make
./CPU-Scheduling-Simulation < ../testcases/01a-input.txt
```

**to run main.cpp**
```plaintext
g++ -std=c++11 -o main main.cpp
./main <testcases/05a-input.txt 

```